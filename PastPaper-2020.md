# Past Paper 2020

## Question 1

FreeRTOS is an open-source real-time operating system (RTOS) kernel that is designed to be small, simple, and easy to use. It is designed to run on microcontroller and other embedded systems, and is particularly well-suited for use in IoT (Internet of Things) devices.

FreeRTOS supports both mutexes and semaphores, which are both types of synchronization mechanisms that can be used to protect shared resources and prevent race conditions. Mutexes are typically used to protect access to shared resources that are accessed by a single task at a time, while semaphores are typically used to protect access to shared resources that can be accessed by multiple tasks concurrently.

FreeRTOS also supports both co-operative and pre-emptive multitasking systems. In a co-operative multitasking system, tasks are responsible for yielding control to other tasks when they have completed their work. In a pre-emptive multitasking system, the RTOS kernel is responsible for deciding when to switch between tasks, based on their priority levels.

FreeRTOS is widely used in a variety of applications, including control systems, industrial automation, medical devices, and consumer electronics. Its small size, low overhead, and ease of use make it a popular choice for many embedded systems developers.

### Q1 Part A

In a FreeRTOS application with two independent tasks that uses a pre-emptive tick-based Round-Robin scheduler, the RTOS kernel is responsible for deciding when to switch between the two tasks. This is done using a tick interrupt, which is generated by a timer at a regular interval (the "tick rate").

When the tick interrupt occurs, the RTOS kernel checks the priority of the current task and the other available tasks to determine which task should run next. If the current task is still able to run (i.e., it has not completed its work or exceeded its time slice), it is allowed to continue running. Otherwise, the RTOS kernel selects the next highest-priority task to run.

This process of switching between tasks is called pre-emptive multitasking, because the RTOS kernel can interrupt the execution of a task at any time in order to switch to another task. This allows the RTOS to ensure that all tasks are given an equal opportunity to run, even if one task takes longer to complete its work.

In contrast, in a co-operative multitasking system, tasks are responsible for yielding control to other tasks when they have completed their work. This means that a task must explicitly give up control in order for another task to run. If a task does not yield control, it can block the execution of other tasks. This can lead to problems if a task becomes stuck or fails to yield control, as it can prevent other tasks from running.

Overall, a pre-emptive multitasking system allows for more efficient resource utilization and better support for real-time constraints, as it can ensure that all tasks are given an equal opportunity to run and that high-priority tasks are given priority over lower-priority tasks. However, it can also be more complex to implement and may require more overhead to switch between tasks.

### Q1 Part B

One benefit of using coding standards in developing embedded systems that use FreeRTOS is that it can help ensure the reliability and maintainability of the code. Coding standards provide a set of guidelines and best practices for writing code, which can help ensure that the code is easy to read, understand, and modify. This can be particularly important in the context of embedded systems, as these systems often have strict real-time constraints and may be required to operate for long periods of time with minimal maintenance.

One drawback of using coding standards is that it can add overhead to the development process, as developers must follow the guidelines and best practices defined in the coding standards. This can increase the time and effort required to develop and maintain the code, which can be a challenge in the context of fast-paced development environments or when working with limited resources.

The AUTOSAR Rule A15-0-7 states that the exception handling mechanism must guarantee a deterministic worst-case execution time. This is important in the context of embedded systems, as these systems often have strict real-time constraints and may be required to perform critical tasks within a certain time frame. Ensuring that the exception handling mechanism has a deterministic worst-case execution time helps ensure that the system can meet these real-time constraints and function reliably in the event of an exception or error.

### Q1 Part C

There are several steps that can be taken using FreeRTOS to eliminate or reduce the undesirable side-effects of a task taking too long to execute:

1. Increase the priority of the task: By increasing the priority of the task, you can ensure that it is given higher priority when the RTOS kernel decides which task to run next. This can help reduce the impact of the task taking too long to execute, as other tasks will not be able to run until the task has completed.

1. Reduce the workload of the task: If the task is taking too long to execute because it has too much work to do, you can try to reduce the workload of the task by breaking it up into smaller tasks or by optimizing the code to run more efficiently.

1. Use a mutex or semaphore: If the task is taking too long to execute because it is accessing a shared resource that is also accessed by other tasks, you can use a mutex or semaphore to synchronize access to the resource. This can help prevent race conditions and ensure that the task is able to complete its work in a timely manner.

1. Use a timer: If the task is taking too long to execute because it is waiting for a specific event to occur, you can use a timer to periodically check for the event and resume the task when it occurs. This can help prevent the task from blocking other tasks for an extended period of time.

1. Use an interrupt: If the task is taking too long to execute because it is waiting for an external event to occur, you can use an interrupt to trigger the task when the event occurs. This can help ensure that the task is able to react to the event in a timely manner.

### Q1 Part D

In FreeRTOS, the proportion of time that tasks are running (i.e., CPU utilization) can be determined using the following approach:

1. Define a global variable to store the total CPU time: This variable will be used to track the total amount of CPU time that has been consumed by all tasks. It can be implemented as a counter that is incremented by the RTOS kernel each time a tick interrupt occurs.

1. Define a global variable to store the total elapsed time: This variable will be used to track the total amount of elapsed time since the system was started. It can be implemented as a counter that is incremented by the RTOS kernel each time a tick interrupt occurs.

1. Calculate the CPU utilization: The CPU utilization can then be calculated by dividing the total CPU time by the total elapsed time and multiplying the result by 100. This will give you the percentage of time that tasks were running relative to the total elapsed time.

1. Reset the counters: To reset the counters and start tracking CPU utilization over a new time period, you can simply set the total CPU time and total elapsed time variables back to zero.

It is important to note that this approach will only give you an estimate of the CPU utilization, as it does not take into account the time spent in interrupt service routines or other non-task code. To get a more accurate measurement of the CPU utilization, you may need to use more advanced techniques, such as hardware performance counters or software profilers.

### Q1 Part E

Advantages of utilizing open-source kernels:

1. Access to the source code: One advantage of using open-source kernels is that the source code is available for anyone to view, modify, and distribute. This can be particularly useful in the case of embedded system failures, as it allows developers to examine the source code and identify the cause of the failure. In contrast, closed-source kernels do not provide access to the source code, which can make it more difficult to diagnose and fix problems.

1. Community support: Another advantage of using open-source kernels is that they often have a large community of developers and users who contribute to the development and maintenance of the kernel. This can provide a wealth of knowledge and resources that can be used to troubleshoot problems and improve the kernel. In contrast, closed-source kernels may not have as strong a community of developers and users, which can make it more difficult to find support or assistance when needed.

Disadvantages of utilizing open-source kernels:

1. Lack of commercial support: One disadvantage of using open-source kernels is that they may not come with commercial support options, such as technical support or warranty protection. This can be a problem in the case of embedded system failures, as it may be difficult to get help or receive compensation for damages. In contrast, closed-source kernels often come with commercial support options that can provide peace of mind and financial protection.

1. Potential for security vulnerabilities: Another disadvantage of using open-source kernels is that they may be more susceptible to security vulnerabilities, as the source code is available for anyone to view and potentially exploit. This can be a concern in the case of embedded systems, as these systems often handle sensitive data or perform critical functions. In contrast, closed-source kernels may be less vulnerable to security threats, as the source code is not publicly available.

## Question 2

It sounds like the temperature monitor you've described is a complex system that utilizes a microcontroller (the ESP8266), temperature sensors, an ADC, and a serial display to monitor and display the temperature in a refrigerator. The system uses interrupt-driven foreground tasks and a cyclic executive running as a background task to ensure that the temperature data is constantly being collected and displayed accurately. The system also utilizes fixed point representation to store the temperature samples, which allows for more precise representation of the temperature data. Overall, it seems like this temperature monitor is designed to be reliable and accurate in ensuring that the temperature in the refrigerator remains within a certain range, which is important for maintaining the integrity of vaccines that are part of the cold chain.

### Q2 Part A

There are a few assembly language instructions and architectural features of the Tensilica XTensa L106 Architecture that could support the high-reliability temperature monitor described in the previous question.

Interrupt handling: The Tensilica XTensa L106 Architecture includes support for interrupt handling, which allows the microcontroller to respond to external events (such as the temperature sensor data being ready to be read) without the need for polling. This can help improve the efficiency and reliability of the temperature monitor, as the microcontroller can respond to new temperature data as soon as it is available, rather than having to continuously check for new data.

Multitasking support: The Tensilica XTensa L106 Architecture also includes support for multitasking, which allows the microcontroller to perform multiple tasks concurrently. This can be useful in the temperature monitor, as it allows the microcontroller to perform both the foreground tasks (reading temperature data from the sensors) and the background tasks (updating the serial display) concurrently, without one task disrupting the other.

Hardware multiply and divide instructions: The Tensilica XTensa L106 Architecture includes hardware support for multiply and divide operations, which can be useful in the temperature monitor for performing calculations on the temperature data. For example, the microcontroller may need to calculate the average temperature across all sensors, which would require performing multiplications and divisions on the temperature samples. Using hardware support for these operations can help improve the efficiency and speed of these calculations.

### Q2 Part B

The maximum rate at which an 80-byte message can be transferred by the UART on the ESP8266 will depend on the baud rate of the UART and the rise/fall time of the output pin (t).

The baud rate is the number of bits that can be transmitted per second over the UART. If the baud rate is B bits per second, then the time it takes to transmit one bit is 1/B seconds.

The rise/fall time of the output pin (t) is the amount of time it takes for the output voltage to transition from low to high (rise) or high to low (fall). This transition time is important because it determines how quickly the UART can change the state of the output pin, and therefore how quickly it can transmit data.

To calculate the maximum rate at which an 80-byte message can be transferred, we need to consider the time it takes to transmit each bit, as well as the time it takes for the output pin to rise or fall.

If the baud rate is B bits per second and the output pin rise/fall time is t microseconds, then the maximum rate at which an 80-byte message can be transferred is:

(80 * 8 bits/byte) / (1/B seconds/bit + 2t microseconds/bit) = 640 bits / (1/B seconds + 2t microseconds)

This equation takes into account the time it takes to transmit each bit (1/B seconds), as well as the time it takes for the output pin to rise and fall (2t microseconds).

To find the maximum rate, we can rearrange the equation to solve for B:

B = 640 bits / (1 second + 2t microseconds)

For example, if the output pin rise/fall time is t = 1 microsecond, then the maximum baud rate would be:

B = 640 bits / (1 second + 2 * 1 microsecond) = 320,000 bits/second

This means that the maximum rate at which an 80-byte message can be transferred is 320,000 bits per second, or 40,000 bytes per second.

It's worth noting that this is the theoretical maximum rate, and in practice the actual transfer rate may be lower due to other factors such as signal noise, interference, or hardware limitations.

### Q2 Part C

In a system like the high-reliability temperature monitor described, foreground tasks and background tasks are typically distinguished by their priority and the degree of interaction they have with the user.

Foreground tasks are typically higher priority tasks that are actively interacting with the user or performing critical functions. In the temperature monitor, the foreground tasks might include reading temperature data from the sensors and storing it in memory, as well as responding to interrupts from the ADC. These tasks are important for constantly collecting and processing temperature data, and may need to be performed as quickly as possible in order to maintain the accuracy of the temperature readings.

On the other hand, background tasks are typically lower priority tasks that perform less critical functions or do not directly interact with the user. In the temperature monitor, the background task might include updating the serial display with the minimum and maximum temperatures recorded across all sensors. This task is important for providing the user with an overview of the temperature data, but it may not need to be performed as frequently or with as much urgency as the foreground tasks.

Overall, the main characteristics that differentiate foreground tasks from background tasks are their priority and the degree of interaction they have with the user. Foreground tasks are typically higher priority tasks that are actively interacting with the user, while background tasks are lower priority tasks that perform less critical functions or do not directly interact with the user.

### Q2 Part D

The front-end circuitry and ADC can have a significant effect on the effective number of bits (ENOB) of stored temperature readings.

The ENOB is a measure of the resolution of an analog-to-digital converter (ADC), and it is related to the number of bits of resolution that the ADC has. The ENOB is typically lower than the actual number of bits of resolution due to various sources of noise and error in the ADC.

The front-end circuitry and ADC can affect the ENOB in a number of ways. For example, if the front-end circuitry is not designed properly, it can introduce noise or other distortions into the analog signal, which can reduce the ENOB. Similarly, if the ADC is not designed properly, it may not be able to accurately convert the analog signal into a digital representation, which can also reduce the ENOB.

To quantify the ENOB of the stored temperature readings, it would be necessary to have information about the temperature sensors and the raw analog signals they produce, as well as information about the front-end circuitry and ADC used to convert the analog signals into digital form. This could include information such as the sensitivity and accuracy of the temperature sensors, the range of the raw analog signals, the noise level of the front-end circuitry, and the resolution and linearity of the ADC.

By analyzing this information, it may be possible to estimate the ENOB of the stored temperature readings and determine how accurately the temperature data is being represented.

### Q2 Part E

The use of interrupt routines can introduce the problem of critical data because interrupts can disrupt the normal flow of a program.

Interrupts are events that cause the microcontroller to stop executing its current program and execute a special interrupt routine instead. This can be useful for responding to external events or for performing time-sensitive tasks, but it can also disrupt the normal flow of a program.

For example, in the high-reliability temperature monitor, the ESP8266 may be using interrupt routines to respond to data ready events from the ADC. When the ADC generates an interrupt, the microcontroller will stop executing its current program and execute the interrupt routine instead. This can be useful for ensuring that the temperature data is constantly being collected and processed, but it can also introduce the problem of critical data.

If the microcontroller is in the middle of updating a critical data structure (such as a buffer used to store temperature samples) when an interrupt occurs, the interrupt routine may overwrite or modify the data in the data structure before the original program has a chance to finish updating it. This can lead to incorrect or inconsistent data being stored, which can affect the reliability of the temperature monitor.

Overall, I agree with the statement that the use of interrupt routines can introduce the problem of critical data, as interrupts can disrupt the normal flow of a program and potentially cause problems with critical data structures. However, with proper design and programming practices, it is possible to mitigate these risks and ensure that the interrupt routines do not interfere with critical data.

## Question 3

### Q3 Part A

### Q3 Part B

### Q3 Part C

### Q3 Part D
